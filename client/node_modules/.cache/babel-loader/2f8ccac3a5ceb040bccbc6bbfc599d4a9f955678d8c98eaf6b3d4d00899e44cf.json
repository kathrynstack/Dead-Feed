{"ast":null,"code":"import { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null);\n  var fromName; // Populate metadata and build a dependency graph.\n\n  visit(documentAST, {\n    OperationDefinition: function OperationDefinition(node) {\n      fromName = opName(node);\n      operations.push(node);\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fromName = node.name.value;\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var toName = node.name.value;\n      var dependents = depGraph[fromName];\n      if (dependents === undefined) {\n        dependents = depGraph[fromName] = Object.create(null);\n      }\n      dependents[toName] = true;\n    }\n  }); // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  var separatedDocumentASTs = Object.create(null);\n  var _loop = function _loop(_i2) {\n    var operation = operations[_i2];\n    var operationName = opName(operation);\n    var dependencies = Object.create(null);\n    collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies[node.name.value];\n      })\n    };\n  };\n  for (var _i2 = 0; _i2 < operations.length; _i2++) {\n    _loop(_i2);\n  }\n  return separatedDocumentASTs;\n}\n\n// Provides the empty string for anonymous operations.\nfunction opName(operation) {\n  return operation.name ? operation.name.value : '';\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  var immediateDeps = depGraph[fromName];\n  if (immediateDeps) {\n    for (var _i4 = 0, _Object$keys2 = Object.keys(immediateDeps); _i4 < _Object$keys2.length; _i4++) {\n      var toName = _Object$keys2[_i4];\n      if (!collected[toName]) {\n        collected[toName] = true;\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}","map":{"version":3,"names":["Kind","visit","separateOperations","documentAST","operations","depGraph","Object","create","fromName","OperationDefinition","node","opName","push","FragmentDefinition","name","value","FragmentSpread","toName","dependents","undefined","separatedDocumentASTs","_loop","_i2","operation","operationName","dependencies","collectTransitiveDependencies","kind","DOCUMENT","definitions","filter","FRAGMENT_DEFINITION","length","collected","immediateDeps","_i4","_Object$keys2","keys"],"sources":["/Users/cole/bootcamp/Dead-Feed/client/node_modules/graphql/utilities/separateOperations.mjs"],"sourcesContent":["import { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null);\n  var fromName; // Populate metadata and build a dependency graph.\n\n  visit(documentAST, {\n    OperationDefinition: function OperationDefinition(node) {\n      fromName = opName(node);\n      operations.push(node);\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fromName = node.name.value;\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var toName = node.name.value;\n      var dependents = depGraph[fromName];\n\n      if (dependents === undefined) {\n        dependents = depGraph[fromName] = Object.create(null);\n      }\n\n      dependents[toName] = true;\n    }\n  }); // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  var separatedDocumentASTs = Object.create(null);\n\n  var _loop = function _loop(_i2) {\n    var operation = operations[_i2];\n    var operationName = opName(operation);\n    var dependencies = Object.create(null);\n    collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies[node.name.value];\n      })\n    };\n  };\n\n  for (var _i2 = 0; _i2 < operations.length; _i2++) {\n    _loop(_i2);\n  }\n\n  return separatedDocumentASTs;\n}\n\n// Provides the empty string for anonymous operations.\nfunction opName(operation) {\n  return operation.name ? operation.name.value : '';\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  var immediateDeps = depGraph[fromName];\n\n  if (immediateDeps) {\n    for (var _i4 = 0, _Object$keys2 = Object.keys(immediateDeps); _i4 < _Object$keys2.length; _i4++) {\n      var toName = _Object$keys2[_i4];\n\n      if (!collected[toName]) {\n        collected[toName] = true;\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,uBAAuB;AAC5C,SAASC,KAAK,QAAQ,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,kBAAkBA,CAACC,WAAW,EAAE;EAC9C,IAAIC,UAAU,GAAG,EAAE;EACnB,IAAIC,QAAQ,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAClC,IAAIC,QAAQ,CAAC,CAAC;;EAEdP,KAAK,CAACE,WAAW,EAAE;IACjBM,mBAAmB,EAAE,SAASA,mBAAmBA,CAACC,IAAI,EAAE;MACtDF,QAAQ,GAAGG,MAAM,CAACD,IAAI,CAAC;MACvBN,UAAU,CAACQ,IAAI,CAACF,IAAI,CAAC;IACvB,CAAC;IACDG,kBAAkB,EAAE,SAASA,kBAAkBA,CAACH,IAAI,EAAE;MACpDF,QAAQ,GAAGE,IAAI,CAACI,IAAI,CAACC,KAAK;IAC5B,CAAC;IACDC,cAAc,EAAE,SAASA,cAAcA,CAACN,IAAI,EAAE;MAC5C,IAAIO,MAAM,GAAGP,IAAI,CAACI,IAAI,CAACC,KAAK;MAC5B,IAAIG,UAAU,GAAGb,QAAQ,CAACG,QAAQ,CAAC;MAEnC,IAAIU,UAAU,KAAKC,SAAS,EAAE;QAC5BD,UAAU,GAAGb,QAAQ,CAACG,QAAQ,CAAC,GAAGF,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;MACvD;MAEAW,UAAU,CAACD,MAAM,CAAC,GAAG,IAAI;IAC3B;EACF,CAAC,CAAC,CAAC,CAAC;EACJ;;EAEA,IAAIG,qBAAqB,GAAGd,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAE/C,IAAIc,KAAK,GAAG,SAASA,KAAKA,CAACC,GAAG,EAAE;IAC9B,IAAIC,SAAS,GAAGnB,UAAU,CAACkB,GAAG,CAAC;IAC/B,IAAIE,aAAa,GAAGb,MAAM,CAACY,SAAS,CAAC;IACrC,IAAIE,YAAY,GAAGnB,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;IACtCmB,6BAA6B,CAACD,YAAY,EAAEpB,QAAQ,EAAEmB,aAAa,CAAC,CAAC,CAAC;IACtE;;IAEAJ,qBAAqB,CAACI,aAAa,CAAC,GAAG;MACrCG,IAAI,EAAE3B,IAAI,CAAC4B,QAAQ;MACnBC,WAAW,EAAE1B,WAAW,CAAC0B,WAAW,CAACC,MAAM,CAAC,UAAUpB,IAAI,EAAE;QAC1D,OAAOA,IAAI,KAAKa,SAAS,IAAIb,IAAI,CAACiB,IAAI,KAAK3B,IAAI,CAAC+B,mBAAmB,IAAIN,YAAY,CAACf,IAAI,CAACI,IAAI,CAACC,KAAK,CAAC;MACtG,CAAC;IACH,CAAC;EACH,CAAC;EAED,KAAK,IAAIO,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGlB,UAAU,CAAC4B,MAAM,EAAEV,GAAG,EAAE,EAAE;IAChDD,KAAK,CAACC,GAAG,CAAC;EACZ;EAEA,OAAOF,qBAAqB;AAC9B;;AAEA;AACA,SAAST,MAAMA,CAACY,SAAS,EAAE;EACzB,OAAOA,SAAS,CAACT,IAAI,GAAGS,SAAS,CAACT,IAAI,CAACC,KAAK,GAAG,EAAE;AACnD,CAAC,CAAC;AACF;;AAGA,SAASW,6BAA6BA,CAACO,SAAS,EAAE5B,QAAQ,EAAEG,QAAQ,EAAE;EACpE,IAAI0B,aAAa,GAAG7B,QAAQ,CAACG,QAAQ,CAAC;EAEtC,IAAI0B,aAAa,EAAE;IACjB,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEC,aAAa,GAAG9B,MAAM,CAAC+B,IAAI,CAACH,aAAa,CAAC,EAAEC,GAAG,GAAGC,aAAa,CAACJ,MAAM,EAAEG,GAAG,EAAE,EAAE;MAC/F,IAAIlB,MAAM,GAAGmB,aAAa,CAACD,GAAG,CAAC;MAE/B,IAAI,CAACF,SAAS,CAAChB,MAAM,CAAC,EAAE;QACtBgB,SAAS,CAAChB,MAAM,CAAC,GAAG,IAAI;QACxBS,6BAA6B,CAACO,SAAS,EAAE5B,QAAQ,EAAEY,MAAM,CAAC;MAC5D;IACF;EACF;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}